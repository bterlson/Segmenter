<!DOCTYPE html>
<meta charset="utf-8">
<pre class="metadata">
title: Intl.Segmenter Proposal
status: proposal
stage: 3
location: https://github.com/tc39/proposal-intl-segmenter
shortname: &lt;a href="https://github.com/tc39/proposal-intl-segmenter"&gt;proposal-intl-segmenter&lt;/a&gt;
copyright: false
contributors: Richard Gibson, Daniel Ehrenberg
</pre>
<emu-biblio href="./biblio.json"></emu-biblio>

<style>
emu-issue {
    margin: 1em 0;
    padding: .5em;
    padding-left: 1em;
    display: block;
}

emu-issue:before {
    display: block;
    padding-bottom: .5em;
    margin-left: -.5em;
}

emu-issue {
    border-left: 5px solid #ff0000;
    background: #ffdddd;
}

emu-issue:before {
    color: #770000;
    content: "ISSUE";
}
</style>


<emu-clause id="segmenter-objects">
  <h1>Segmenter Objects</h1>

  <emu-clause id="sec-intl-segmenter-constructor">
    <h1>The Intl.Segmenter Constructor</h1>

    <p>
      The Segmenter constructor is the <dfn>%Segmenter%</dfn> intrinsic object and a standard built-in property of the Intl object. Behaviour common to all service constructor properties of the Intl object is specified in <emu-xref href="#sec-internal-slots"></emu-xref>.
    </p>

    <emu-clause id="sec-Intl.Segmenter">
      <h1>Intl.Segmenter ([ _locales_ [ , _options_ ]])</h1>

      <p>
        When the `Intl.Segmenter` function is called with optional arguments _locales_ and _options_, the following steps are taken:
      </p>

      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _internalSlotsList_ be &laquo; [[InitializedSegmenter]], [[Locale]], [[SegmenterGranularity]] &raquo;.
        1. Let _segmenter_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%SegmenterPrototype%"`, _internalSlotsList_).
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. If _options_ is *undefined*, then
          1. Let _options_ be ObjectCreate(*null*).
        1. Else
          1. Let _options_ be ? ToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _matcher_ be ? GetOption(_options_, `"localeMatcher"`, `"string"`, &laquo; `"lookup"`, `"best fit"` &raquo;, `"best fit"`).
        1. Set _opt_.[[localeMatcher]] to _matcher_.
        1. Let _localeData_ be %Segmenter%.[[LocaleData]].
        1. Let _r_ be ResolveLocale(%Segmenter%.[[AvailableLocales]], _requestedLocales_, _opt_, %Segmenter%.[[RelevantExtensionKeys]], _localeData_).
        1. Set _segmenter_.[[Locale]] to the value of _r_.[[locale]].
        1. Let _granularity_ be ? GetOption(_options_, `"granularity"`, `"string"`, &laquo; `"grapheme"`, `"word"`, `"sentence"` &raquo;, `"grapheme"`).
        1. Set _segmenter_.[[SegmenterGranularity]] to _granularity_.
        1. Return _segmenter_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-segmenter-constructor">
    <h1>Properties of the Intl.Segmenter Constructor</h1>

    <p>
      The Intl.Segmenter constructor has the following properties:
    </p>

    <emu-clause id="sec-Intl.Segmenter.prototype">
      <h1>Intl.Segmenter.prototype</h1>

      <p>
        The value of `Intl.Segmenter.prototype` is %SegmenterPrototype%.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Segmenter.supportedLocalesOf">
      <h1>Intl.Segmenter.supportedLocalesOf ( _locales_ [, _options_ ])</h1>

      <p>
        When the `supportedLocalesOf` method is called with arguments _locales_ and _options_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _availableLocales_ be %Segmenter%.[[AvailableLocales]].
        1. Let _requestedLocales_ be ? CanonicalizeLocaleList(_locales_).
        1. Return ? SupportedLocales(_availableLocales_, _requestedLocales_, _options_).
      </emu-alg>

      <p>
        The value of the `length` property of the *supportedLocalesOf* method is 1.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Segmenter-internal-slots">
      <h1>Internal slots</h1>

      <p>
        The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref>.
      </p>
        
      <p>
        The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref>.
      </p>
        
      <p>
        The value of the [[RelevantExtensionKeys]] internal slot is &laquo; &raquo;.
      </p>

      <emu-note>
        CLDR defines several extension keys, but this specification does not expose them.
      </emu-note>

    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-segmenter-prototype-object">
    <h1>Properties of the Intl.Segmenter Prototype Object</h1>

    <p>
      The Intl.Segmenter prototype object is itself an ordinary object. <dfn>%SegmenterPrototype%</dfn> is not an Intl.Segmenter instance and does not have an [[InitializedSegmenter]] internal slot or any of the other internal slots of Intl.Segmenter instance objects.
    </p>

    <emu-clause id="sec-Intl.Segmenter.prototype.constructor">
      <h1>Intl.Segmenter.prototype.constructor</h1>

      <p>
        The initial value of `Intl.Segmenter.prototype.constructor` is the intrinsic object %Segmenter%.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Segmenter.prototype-@@tostringtag">
      <h1>Intl.Segmenter.prototype[ @@toStringTag ]</h1>

      <p>
        The initial value of the @@toStringTag property is the string value `"Object"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Segmenter.prototype.segment" aoid="Intl.Segmenter.prototype.segment">
      <h1>Intl.Segmenter.prototype.segment( _string_ )</h1>

      <p>
        When the *Intl.Segmenter.prototype.segment* is called with an argument _string_, the following steps are taken:
      </p>

      <emu-alg>
        1. Let _segment_ be *this* value.
        1. If Type(_segment_) is not Object or _segment_ does not have an [[InitializedSegmenter]] internal slot, throw a *TypeError* exception.
        1. Let _string_ be ? ToString(_string_).
        1. Return ? CreateBoundaryIterator(_segment_, _string_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Segmenter.prototype.resolvedOptions">
      <h1>Intl.Segmenter.prototype.resolvedOptions ()</h1>

      <p>
        This function provides access to the locale and options computed during initialization of the object.
      </p>

      <emu-alg>
        1. Let _segmenter_ be the *this* value.
        1. If Type(_segmenter_) is not Object, throw a *TypeError* exception.
        1. If _segmenter_ does not have an [[InitializedSegmenter]] internal slot, throw a *TypeError* exception.
        1. Let _options_ be ! ObjectCreate(%ObjectPrototype%).
        1. For each row of <emu-xref href="#table-segmenter-resolvedoptions-properties"></emu-xref>, except the header row, in table order, do
          1. Let _p_ be the Property value of the current row.
          1. Let _v_ be the value of _segmenter_'s internal slot whose name is the Internal Slot value of the current row.
          1. If _v_ is not *undefined*, then
            1. Perform ! CreateDataPropertyOrThrow(_options_, _p_, _v_).
        1. Return _options_.
      </emu-alg>

      <emu-table id="table-segmenter-resolvedoptions-properties">
        <emu-caption>Resolved Options of Segmenter Instances</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
            </tr>
          </thead>
          <tr>
            <td>[[Locale]]</td>
            <td>`"locale"`</td>
          </tr>
          <tr>
            <td>[[SegmenterGranularity]]</td>
            <td>`"granularity"`</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-segmenter-instances">
    <h1>Properties of Intl.Segmenter Instances</h1>

    <p>
      Intl.Segmenter instances inherit properties from %SegmenterPrototype%.
    </p>

    <p>
      Intl.Segmenter instances have an [[InitializedSegmenter]] internal slot.
    </p>

    <p>
      Intl.Segmenter instances also have several internal slots that are computed by the constructor:
    </p>

    <ul>
      <li>[[Locale]] is a String value with the language tag of the locale whose localization is used for segmentation.</li>
      <li>[[SegmenterGranularity]] is one of the String values `"grapheme"`, `"word"`, or `"sentence"`, identifying the kind of text element to segment.</li>
    </ul>

  </emu-clause>

  <emu-clause id="boundary-iterator-objects">
    <h1>Boundary Iterators</h1>

    <p>
      The Intl.Segment.prototype.segment method returns iterators over the segments for a particular string. This section describes those iterator objects.
    </p>

    <emu-clause id="sec-CreateBoundaryIterator" aoid="CreateBoundaryIterator">
      <h1>CreateBoundaryIterator ( _segmenter_, _string_ )</h1>
      <p>When the abstract operation CreateBoundaryIterator is called with Segmenter _segmenter_ and string _string_, the following steps are taken:</p>
      <emu-alg>
        1. Let _iterator_ be ObjectCreate(%BoundaryIteratorPrototype%).
        1. Let _iterator_.[[BoundaryIteratorSegmenter]] be _segmenter_.
        1. Let _iterator_.[[BoundaryIteratorString]] be _string_.
        1. Let _iterator_.[[BoundaryIteratorIndex]] be 0.
        1. Let _iterator_.[[BoundaryIteratorPrecedingSegmentType]] be *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-AdvanceBoundaryIterator" aoid="AdvanceBoundaryIterator">
      <h1>AdvanceBoundaryIterator ( _iterator_, _direction_ )</h1>
      <p>The abstract operation AdvanceBoundaryIterator takes as arguments a boundary iterator _iterator_ and a ~forwards~ or ~backwards~ _direction_. The operation attempts to advance the iterator to the next boundary in the given direction according to the effective locale and options of the iterator's constructing segmenter, and returns a Boolean value that is *true* if and only if iteration in the given direction was already complete. It performs the following steps:</p>
      <emu-note>Boundary determination is implementation-dependent, but general default algorithms are specified in Unicode Standard Annex 29 (available at <a href="https://www.unicode.org/reports/tr29/">https://www.unicode.org/reports/tr29/</a>). It is recommended that implementations use locale-sensitive tailorings such as those provided by the Common Locale Data Repository (available at <a href="http://cldr.unicode.org">http://cldr.unicode.org</a>).</emu-note>
      <emu-alg>
        1. Let _segmenter_ be _iterator_.[[BoundaryIteratorSegmenter]].
        1. Let _locale_ be _segmenter_.[[Locale]].
        1. Let _granularity_ be _segmenter_.[[SegmenterGranularity]].
        1. Let _string_ be _iterator_.[[BoundaryIteratorString]].
        1. Let _lastIndex_ be _iterator_.[[BoundaryIteratorIndex]].
        1. If _direction_ is ~forwards~, then
          1. Let _len_ be the length of _string_.
          1. If _lastIndex_ is _len_, return *true*.
          1. Using locale _locale_ and granularity _granularity_, find the first boundary in _string_ that follows the code unit at index _lastIndex_.
          1. Assert: A boundary was found.
          1. If the boundary is at the end of _string_, let _nextIndex_ be _len_. Otherwise, let _nextIndex_ be the integer index in _string_ that immediately follows the boundary.
        1. Else
          1. Assert: _direction_ is ~backwards~.
          1. If _lastIndex_ is 0, return *true*.
          1. Using locale _locale_ and granularity _granularity_, find the last boundary in _string_ that precedes the code unit at index _lastIndex_ - 1.
          1. If no boundary was found, let _nextIndex_ be 0. Otherwise, let _nextIndex_ be the integer index in _string_ that immediately follows the boundary.
        1. Set _iterator_.[[BoundaryIteratorIndex]] to _nextIndex_.
        1. If _nextIndex_ = 0, then
          1. Set _iterator_.[[BoundaryIteratorPrecedingSegmentType]] to *undefined*.
        1. Else
          1. Assert: _granularity_ is listed in the &ldquo;Granularity&rdquo; column of <emu-xref href="#segment-type-table"></emu-xref>.
          1. Using locale _locale_ and granularity _granularity_, find the last boundary in _string_ that precedes the code unit at index _nextIndex_ - 1.
          1. If no boundary was found, let _segmentStart_ be 0. Otherwise, let _segmentStart_ be the integer index in _string_ that immediately follows the boundary.
          1. Let _precedingSegment_ be the String value containing consecutive code units from _string_ beginning with the code unit at index _segmentStart_ and ending with the code unit at index _nextIndex_ - 1.
          1. Set _iterator_.[[BoundaryIteratorPrecedingSegmentType]] to the value from the &ldquo;Segment Type&rdquo; column of the row in <emu-xref href="#segment-type-table"></emu-xref> in which the &ldquo;Granularity&rdquo; column matches _granularity_ and the &ldquo;Meaning&rdquo; column describes _precedingSegment_ according to the locale _locale_.
        1. Return *false*.
      </emu-alg>
      <emu-table id="segment-type-table" caption="Segment Types">
        <table>
          <tr>
            <th>Granularity</th>
            <th>Segment Type</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>`"grapheme"`</td>
            <td>*undefined*</td>
            <td>a grapheme cluster</td>
          </tr>
          <tr>
            <td>`"word"`</td>
            <td>`"word"`</td>
            <td>a segment containing numbers, letters, kana, ideographic characters, or other word-like contents</td>
          </tr>
          <tr>
            <td>`"word"`</td>
            <td>`"none"`</td>
            <td>a segment that is not word-like, often consisting of spaces or punctuation</td>
          </tr>
          <tr>
            <td>`"sentence"`</td>
            <td>`"term"`</td>
            <td>a segment that ends with a sentence terminator ('.', '?', '!', etc.) optionally followed by any amount of closing punctuation ('"', ']', '»', etc.), any amount of whitespace, and then an optional hard separator (&lt;CR&gt;, &lt;LF&gt;, &lt;PS&gt;, etc.)</td>
          </tr>
          <tr>
            <td>`"sentence"`</td>
            <td>`"sep"`</td>
            <td>a segment that does not end with a sentence terminator ('.', '?', '!', etc.) section, but is either at the end of the string or ends with a hard separator (&lt;CR&gt;, &lt;LF&gt;, &lt;PS&gt;, etc.)</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-boundary-iterator-prototype">
      <h1>%BoundaryIteratorPrototype%</h1>
      The %BoundaryIteratorPrototype% object:
      <ul>
        <li>is the prototype of all boundary iterators.</li>
        <li>is an ordinary object.</li>
        <li>has a [[Prototype]] internal slot whose value is the intrinsic object %IteratorPrototype%.</li>
        <li>has the following properties:
      </ul>
      <emu-clause id="sec-boundary-iterator-prototype-next">
        <h1>%BoundaryIteratorPrototype%.next( )</h1>
        <emu-alg>
          1. Let _iterator_ be *this* value.
          1. If _iterator_ does not have a [[BoundaryIteratorSegmenter]] internal slot, throw a *TypeError* exception.
          1. Let _previousIndex_ be _iterator_.[[BoundaryIteratorIndex]].
          1. Let _done_ be AdvanceBoundaryIterator(_iterator_, ~forwards~).
          1. If _done_ is *true*, return CreateIterResultObject(*undefined*, *true*).
          1. Let _newIndex_ be _iterator_.[[BoundaryIteratorIndex]].
          1. Let _string_ be _iterator_.[[BoundaryIteratorString]].
          1. Let _precedingSegmentType_ be _iterator_.[[BoundaryIteratorPrecedingSegmentType]].
          1. Let _result_ be ! ObjectCreate(%ObjectPrototype%).
          1. Perform ! CreateDataProperty(_result_, `"precedingSegmentType"`, _precedingSegmentType_).
          1. Perform ! CreateDataProperty(_result_, `"index"`, _newIndex_).
          1. Return CreateIterResultObject(_result_, *false*).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundary-iterator-prototype-following">
        <h1>%BoundaryIteratorPrototype%.following( [ _from_ ] )</h1>
        <p>The `following` method moves the iterator index to the boundary following the code unit index _from_ (or after the current index of the iterator if _from_ is *undefined*) and returns a Boolean value that is *true* if and only if the end of the string was reached. It performs the following steps:</p>
        <emu-alg>
          1. Let _iterator_ be *this* value.
          1. If _iterator_ does not have a [[BoundaryIteratorSegmenter]] internal slot, throw a *TypeError* exception.
          1. Let _length_ be the length of _iterator_.[[BoundaryIteratorString]].
          1. If _from_ is not *undefined*, then
            1. Let _from_ be ? ToIndex(_from_).
            1. If _from_ &lt; 0 or _from_ &ge; _length_, throw a *RangeError* exception.
            1. Let _iterator_.[[BoundaryIteratorIndex]] be _from_.
          1. Perform ! AdvanceBoundaryIterator(_iterator_, ~forwards~).
          1. If _iterator_.[[BoundaryIteratorIndex]] = _length_, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundary-iterator-prototype-preceding">
        <h1>%BoundaryIteratorPrototype%.preceding( [ _from_ ] )</h1>
        <p>The `preceding` method moves the iterator index to the boundary preceding the position before the code unit index _from_ (or before the current index of the iterator if _from_ is *undefined*) and returns a Boolean value that is *true* if and only if the beginning of the string was reached. It performs the following steps:</p>
        <emu-alg>
          1. Let _iterator_ be *this* value.
          1. If _iterator_ does not have a [[BoundaryIteratorSegmenter]] internal slot, throw a *TypeError* exception.
          1. If _from_ is not *undefined*, then
            1. Let _from_ be ? ToIndex(_from_).
            1. Let _length_ be the length of _iterator_.[[BoundaryIteratorString]].
            1. If _from_ = 0 or _from_ &gt; _length_, throw a *RangeError* exception.
            1. Let _iterator_.[[BoundaryIteratorIndex]] be _from_.
          1. Perform ! AdvanceBoundaryIterator(_iterator_, ~backwards~).
          1. If _iterator_.[[BoundaryIteratorIndex]] = 0, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundary-iterator-prototype-index">
        <h1>get %BoundaryIteratorPrototype%.index</h1>
        <emu-alg>
          1. Let _iterator_ be *this* value.
          1. If _iterator_ does not have a [[BoundaryIteratorSegmenter]] internal slot, throw a *TypeError* exception.
          1. Return _iterator_.[[BoundaryIteratorIndex]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundary-iterator-prototype-precedingSegmentType">
        <h1>get %BoundaryIteratorPrototype%.precedingSegmentType</h1>
        <emu-alg>
          1. Let _iterator_ be *this* value.
          1. If _iterator_ does not have a [[BoundaryIteratorSegmenter]] internal slot, throw a *TypeError* exception.
          1. Return _iterator_.[[BoundaryIteratorPrecedingSegmentType]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
